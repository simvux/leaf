#![feature(option_expect_none)]
#![feature(box_patterns)]
use lumina_util::{Ign, Location, LocationError, Tr};
use std::collections::HashMap;
use std::fmt;

mod error;
pub use error::Error;

pub mod ast;

mod r#type;
pub use r#type::{DefType, Enum, Struct, Trait, Type, TypeKind, TypeParameters, TypeParams};

mod attribute;
pub use attribute::Attr;

/// FileParser reads a file and streams the resulting AST into the handler
pub struct FileParser<'h, H, E> {
    handler: &'h mut H,
    e: std::marker::PhantomData<E>,
}

/// HandlerError is either an error from our parser, or an error returned by the handler
#[derive(Debug)]
pub enum HandlerError<E> {
    Parser(Error),
    ParserPositioned(lumina_util::Error),
    Handler(E),
}

impl<E: fmt::Display> fmt::Display for HandlerError<E> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            HandlerError::Parser(error) => error.fmt(f),
            HandlerError::ParserPositioned(error) => error.fmt(f),
            HandlerError::Handler(error) => error.fmt(f),
        }
    }
}

impl<E: std::error::Error> std::error::Error for HandlerError<E> {}

impl<E> From<Error> for HandlerError<E> {
    fn from(e: Error) -> HandlerError<E> {
        HandlerError::Parser(e)
    }
}
impl<E> From<LocationError> for HandlerError<E> {
    fn from(e: LocationError) -> HandlerError<E> {
        HandlerError::Parser(Error::from(e))
    }
}

impl<E> HandlerError<E> {
    pub fn map_handler(self, f: impl Fn(E) -> E) -> Self {
        match self {
            HandlerError::Handler(e) => HandlerError::Handler(f(e)),
            other => other,
        }
    }
}

/// The Handler handles the AST stream generated by the FileParser
pub trait Handler<E> {
    fn on_use(
        &mut self,
        assign_to: Tr<String>,
        import: Tr<Location>,
        exposing: Vec<Tr<String>>,
    ) -> Result<(), HandlerError<E>>;

    fn on_func(&mut self, func: Tr<ast::Function>) -> Result<(), E>;
    fn on_type(&mut self, type_: DefType) -> Result<(), E>;
    fn on_impl(
        &mut self,
        decl_span: lumina_tokenizer::Span,
        trait_: Tr<Location>,
        type_parameters: Vec<Tr<Type>>,
        bounds: ast::Bounds<Type>,
        for_t: Tr<Type>,
        impl_: HashMap<String, Tr<ast::Function>>,
    ) -> Result<(), E>;
}

impl<'h, E, H: Handler<E>> FileParser<'h, H, E> {
    /// Opens a `.lm` file, and parses all functions/types/imports etc, and calls those respective handlers
    pub fn parse(mut self, source_code: &str, filename: &str) -> Result<(), HandlerError<E>> {
        ast::Builder::from_str(&mut self, source_code)
            .run()
            .map_err(|e| match e {
                HandlerError::Parser(e) => HandlerError::ParserPositioned(
                    lumina_util::ToError::into_lumina_error(e, source_code, filename.to_string()),
                ),
                other => other,
            })
    }
}

impl<'h, H, E> FileParser<'h, H, E> {
    pub fn new(handler: &'h mut H) -> Self {
        FileParser {
            handler,
            e: std::marker::PhantomData,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use lumina_util::PFlags;

    fn trstr(s: &str) -> Tr<String> {
        Tr::new(s.to_string())
    }

    fn test_parser<'a, E>(handler: &'a mut Tester) -> FileParser<'a, Tester, E> {
        FileParser::new(handler)
    }

    struct Tester {}

    impl<E> Handler<E> for Tester {
        fn on_use(
            &mut self,
            _assign_to: Tr<String>,
            _import: Tr<Location>,
            _exposing: Vec<Tr<String>>,
        ) -> Result<(), HandlerError<E>> {
            todo!();
        }
        fn on_func(&mut self, func: Tr<ast::Function>) -> Result<(), E> {
            assert_eq!(
                func.inner,
                ast::Function {
                    name: "add".into(),
                    header: ast::function::Header {
                        pnames: vec![trstr("x"), trstr("y")],
                        ptypes: vec![Tr::new(Type::Int), Tr::new(Type::Int)],
                        pflags: PFlags::new(),
                        bounds: ast::Bounds::new(),
                        returns: Tr::new(Type::Int),
                        attributes: Vec::new(),
                    },
                    body: ast::function::Body {
                        entity: Tr::new(ast::Entity::Identifier {
                            takes: Location::from_str("body").unwrap(),
                            params: vec![]
                        }),
                        wheres: Vec::new(),
                    },
                }
            );
            Ok(())
        }
        fn on_type(&mut self, type_: DefType) -> Result<(), E> {
            let hardcoded = match type_.kind {
                TypeKind::Struct(_) => DefType {
                    name: "point".into(),
                    span: Ign::new(0..0),
                    attributes: vec![],
                    type_parameters: vec![Tr::new(1), Tr::new(2)],
                    kind: TypeKind::Struct(Struct {
                        fields: vec![
                            (Tr::new("x".into()), Tr::new(Type::Int)),
                            (Tr::new("y".into()), Tr::new(Type::Int)),
                        ],
                    }),
                },
                TypeKind::Trait(_) => {
                    let mut functions = HashMap::new();
                    functions.insert(
                        "int".into(),
                        (
                            Tr::new(ast::function::Header {
                                pnames: vec![],
                                ptypes: vec![Tr::new(Type::TraitSelf(vec![]))],
                                pflags: PFlags::new(),
                                bounds: ast::Bounds::new(),
                                returns: Tr::new(Type::Int),
                                attributes: vec![],
                            }),
                            0,
                        ),
                    );

                    DefType {
                        name: "ToInt".into(),
                        span: Ign::new(0..0),
                        type_parameters: vec![Tr::new(1), Tr::new(2)],
                        attributes: vec![],
                        kind: TypeKind::Trait(Trait { functions }),
                    }
                }
                _ => unreachable!(),
            };
            assert_eq!(hardcoded.name, type_.name);
            assert_eq!(hardcoded.kind, type_.kind);
            assert_eq!(hardcoded.attributes, type_.attributes);
            Ok(())
        }
        fn on_impl(
            &mut self,
            _decl_span: lumina_tokenizer::Span,
            trait_: Tr<Location>,
            _type_parameters: Vec<Tr<Type>>,
            _bounds: ast::Bounds<Type>,
            for_t: Tr<Type>,
            impl_: HashMap<String, Tr<ast::Function>>,
        ) -> Result<(), E> {
            assert_eq!(*trait_, Location::from_str("ToInt").unwrap());

            let mut map = HashMap::with_capacity(impl_.len());
            map.insert(
                "int".into(),
                Tr::new(ast::Function {
                    name: "int".into(),
                    header: ast::function::Header {
                        pnames: vec![trstr("n")],
                        ptypes: vec![Tr::new(Type::Int)],
                        pflags: PFlags::new(),
                        bounds: ast::Bounds::new(),
                        returns: Tr::new(Type::Int),
                        attributes: Vec::new(),
                    },
                    body: ast::function::Body {
                        entity: Tr::new(ast::Entity::Identifier {
                            takes: Location::from_str("n").unwrap(),
                            params: vec![],
                        }),
                        wheres: Vec::new(),
                    },
                }),
            );
            assert_eq!(impl_, map);
            assert_eq!(*for_t, Type::Int);
            Ok(())
        }
    }

    #[test]
    fn handlers() {
        let mut handler = Tester {};

        let mut module = test_parser::<()>(&mut handler);

        let src = "
fn add x y (int, int -> int) body

struct point b c
    x int
    y int

trait ToInt b c
    fn int (self -> int)

impl ToInt for int
    fn int n (int -> int)
        n
            ";

        let builder = ast::Builder::from_str(&mut module, src);
        let _v = builder.headers(vec![]).unwrap();
    }
}
