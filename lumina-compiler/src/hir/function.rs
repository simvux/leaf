use super::{function, Location, SelfPosition, Type};
use crate::Typing as BaseTyping;
use lumina_parser::ast;
use lumina_typesystem::{ITp, IType, Tp};
use lumina_util::Tr;
use std::rc::Rc;

/// Information about a function that's consistent accross all the different kinds of functions.
#[derive(Clone, Debug)]
pub enum Header {
    Known(Typing),
    Failed(PoisonedTyping),
}

impl Header {
    pub fn new(typing: Typing) -> Self {
        Self::Known(typing)
    }

    pub fn failed(salvaged: PoisonedTyping) -> Self {
        Self::Failed(salvaged)
    }

    pub fn params_len(&self) -> usize {
        match self {
            Header::Known(a) => a.ptypes.len(),
            Header::Failed(a) => a.ptypes.len(),
        }
    }
}

/// Parameters and return type of a function in the HIR
pub type Typing = BaseTyping<Tp<Type>>;
pub type PoisonedTyping = BaseTyping<ITp<IType>>;

/*
/// HACK: the `self` type in methods cannot be put in the hir::function::Header as it's stored next
/// to functions. So; we generate this fake type in the hopes that `self_position` will be
/// correctly managed.
pub fn method_self_type() -> Type {
    Type::defined(std::usize::MAX)
}
*/

/// Kind allows us to differentiate between the kinds of functions and store kind-specific
/// information.
///
/// A lot of functions in the compiler aren't even actually in the source code but are rather
/// generated by the compiler itself.
#[derive(Clone, Debug)]
pub enum Kind {
    Defined(Rc<Location>, Box<Body>),
    Where(Box<Entity>),

    /// Since these are called as functions through a symbol; they also hold their location as data.
    Accessor {
        struct_: Rc<Location>,
        field: usize,
    },
    Constructor {
        enum_: Rc<Location>,
        variant: usize,
    },

    Method {
        trait_: Rc<Location>,
        traitid: usize,
        methodid: usize,
        self_position: SelfPosition,
    },

    DefinedMethod {
        traitid: usize,
        methodid: usize,
        self_position: SelfPosition,
        body: Box<Body>,
    },

    /// When a function fails its compilation, we need to make sure we still add *some* function so
    /// it doesn't redo that function and fail it again if it's called multiple times without
    /// existing for inference hints.
    Poisoned,
}

#[derive(Clone, Debug)]
pub enum Value {
    Int(i64),
}

#[derive(Clone, Debug)]
pub enum Entity {
    DotCall(String, Box<Tr<Self>>),

    /// Both of these are actually just lambdas.
    ///
    /// But we still differentiate between them for error handling
    Lambda(function::Header, Tr<Box<Entity>>, Vec<Tr<Self>>),
    First(function::Header, Tr<Box<Entity>>, Vec<Tr<Self>>),

    Identifier(Identifier, Vec<Tr<Self>>),
    ExprCall(Box<Self>, Vec<Tr<Self>>),
    Inlined(Value),
    Builtin(lumina_util::Builtin<usize, Self>),
    Match {
        kind: MatchKind,
        of: Tr<Box<Self>>,
        patterns: super::PatternTable,
        evals: Vec<(Header, Tr<Self>, Vec<Tr<String>>)>,
    },
    If(ast::r#if::Expr<Tr<Self>>),

    Pass(Box<Self>),
    Cast(Box<Self>, Tp<Type>),

    List(usize, Vec<Tr<Self>>),

    ModifyRecord(Box<Tr<Entity>>, Vec<(String, Tr<Self>)>),
    ConstructRecord(usize, Vec<super::Type>, Vec<Tr<Self>>),
    Tuple(Vec<Tr<Self>>),

    Unimplemented,
}

#[derive(Clone, Debug, Copy)]
pub enum MatchKind {
    UserWritten,
    LetBind,
}

/// An verified and ID'd representation of an identifier
#[derive(Clone, Debug)]
pub enum Identifier {
    Function(usize),
    Method { trid: usize, mid: usize },
    Where(usize),
    Param(usize),
    Parent(Box<Identifier>),
}

/*
#[derive(Clone, Debug)]
pub struct Body {
    pub entity: Entity,
}
*/
/// The body of a function
pub type Body = Entity;

/// A where binding of a function
#[derive(Clone, Debug)]
pub enum WhereBinding {
    // Function(Header, Entity),
    Function(super::Function),
    Let(Entity, Tp<Type>),
}
